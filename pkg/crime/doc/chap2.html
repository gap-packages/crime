<?xml version="1.0" encoding="ISO-8859-1"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (crime) - Chapter 2: Usage</title>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
</head>
<body>


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>
<p><a id="s0ss0" name="s0ss0"></a></p>

<h3>2. Usage</h3>

<p>All the functions described below taking an argument <code class="keyw">n</code> except <code class="keyw">CohomologyRing</code> do whatever the manual says they do until some stage <code class="keyw">n</code>, where <code class="keyw">n</code> is normally the homological degree. These functions are idempotent in the sense that called a second time with the same argument <code class="keyw">n</code>, they do nothing, but called with a bigger <code class="keyw">n</code>, they continue computing from where the previous calculations left off.</p>

<p><a id="s1ss0" name="s1ss0"></a></p>

<h4>2.1 Cohomology Objects</h4>

<p>The calculation of group cohomology involves several computations, the results of which are reused in later calculations, and are thus collected in an object of type <code class="keyw">CObject</code>, created with the following operation.</p>

<p><a id="s1ss1" name="s1ss1"></a></p>

<h5>2.1-1 CohomologyObject</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CohomologyObject</code>( <var>G, k, M</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CohomologyObject</code>( <var>G</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>a cohomology object.</p>

<p>This function creates a cohomology object, initially having components the p-group G, the field k of characteristic p, and the <strong class="pkg">MeatAxe</strong> kG-module M. The second invocation creates a cohomology object, initially having components the p-group G, the field GF(p), and the trivial <strong class="pkg">MeatAxe</strong> kG-module.</p>

<p>The cohomology object is used to store, in addition to the group, field, and module, the boundary maps, the Betti numbers, the multiplication table, etc.</p>

<p><a id="s2ss0" name="s2ss0"></a></p>

<h4>2.2 Minimal Projective Resolutions</h4>

<p>Given a p-group G, the field k of characteristic p and a kG-module M, the function below computes a minimal projective resolution</p>

<p class="pcenter">\[P_n -> ... P_2 -> P_1 -> P_0 -> k -> 0 \]</p>

<p>where P_i=(kG)^(b_i) for certain numbers b_i, the <em>Betti numbers</em> of the resolution. Then the groups Ext^n(M,N) are simply Hom(P_n,N), and if N=k is the trivial kG-module, then H^n(G,k)=Ext^n(k,k)=k^(b_n).</p>

<p><a id="s2ss1" name="s2ss1"></a></p>

<h5>2.2-1 ProjectiveResolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; ProjectiveResolution</code>( <var>C, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>a list containing the Betti numbers b_0, b_1,..., b_n.</p>

<p>Given a cohomology object <code class="keyw">C</code> having components G, k, and M, this function computes the first <code class="keyw">n</code>+1 terms of the minimal projective resolution P* of M of the form P_i=(kG)^(b_i) for i=0,1,...,n, and returns the numbers b_i as a list.</p>

<p><a id="s3ss0" name="s3ss0"></a></p>

<h4>2.3 Cohomology Generators and Relators</h4>

<p><a id="s3ss1" name="s3ss1"></a></p>

<h5>2.3-1 CohomologyGenerators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CohomologyGenerators</code>( <var>C, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>a list containing the degrees of the generators of the cohomology ring.</p>

<p>Given a cohomology object <code class="keyw">C</code> having components G, k, and M, this function computes the generators of H*(G,k) of degree less than or equal to <code class="keyw">n</code>, and stores them in <code class="keyw">C</code>. The function returns a list of the degrees of the generators.</p>

<p>The actual cohomology generators are represented by maps P_n -&gt; k and are stored in <code class="keyw">C</code> as column vectors. Only their degrees are returned.</p>

<p><a id="s3ss2" name="s3ss2"></a></p>

<h5>2.3-2 CohomologyRelators</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CohomologyRelators</code>( <var>C, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>a list of generators and a list of relators.</p>

<p>Given a cohomology object <code class="keyw">C</code> having components G, k, and M, this function computes a set of generators of the ideal of relators of H*(G,k) having multidegree less than or equal to n.</p>

<p>The function returns two lists, the first containing the variables <code class="keyw">z</code>, <code class="keyw">y</code>, <code class="keyw">x</code>, ... corresponding to the generators of H*(G,k) if there are fewer than 12 generators, and containing the variables <code class="keyw">x_1</code>, <code class="keyw">x_2</code>, <code class="keyw">x_3</code>, ... otherwise. The second is a list of polynomials in the variables from the first list.</p>

<p>These two lists should be interpreted as follows. The degree <code class="keyw">n</code> truncation of the cohomology ring H*(G,k) is the polynomial ring in the non-commuting variables from the first list, having the degrees returned by <code class="keyw">CohomologyGenerators</code> above, and subject to the relators in the second list.</p>

<p>For example, the following commands</p>


<table class="example">
<tr><td><pre>


gap&gt; C:=CohomologyObject(DihedralGroup(8));
&lt;object&gt;
gap&gt; CohomologyGenerators(C,10);
[ 1, 1, 2 ]
gap&gt; CohomologyRelators(C,10);
[ [ z, y, x ], [ z*y+y^2 ] ]


</pre></td></tr></table>

<p>tell us that for G=D_8, the cohomology ring H*(G,k) is the graded-commutative polynomial ring in the variables z, y, and x of degrees 1, 1, and 2, subject to the relation zy+y^2. But since H*(G,k) <em>is</em> commutative, k being of characteristic 2, we have H*(G,k)=k[z,y,x]/(zy+y^2). This result can be further improved by taking z=z+y, giving H*(G,k)=k[z,y,x]/(zy).</p>

<p><a id="s4ss0" name="s4ss0"></a></p>

<h4>2.4 Cohomology Rings</h4>

<p>See <a href="chapBib.html#biBcarlson">[CT+03]</a> for the details of the calculation of cohomology products using composition of chain maps. See also the file <code class="keyw">doc/explanation.tex</code> for an explanation of the implementation.</p>

<p><a id="s4ss1" name="s4ss1"></a></p>

<h5>2.4-1 CohomologyRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CohomologyRing</code>( <var>C, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; CohomologyRing</code>( <var>G, n</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b>the cohomology ring of G.</p>

<p>Given a cohomology object <code class="keyw">C</code> having module component the trivial kG-module and possibly having a projective resolution already computed, this function returns the degree <code class="keyw">n</code> truncation of the cohomology ring H*(G,k). The object returned is an structure constant algebra.</p>

<p>Users interested only in working with the cohomology ring of a group as a <strong class="pkg">GAP</strong> object, and not in calculating generators, relators, induced maps, etc, can use the second invocation of this function, which returns the cohomology ring of the group <code class="keyw">G</code> immediately, throwing away all intermediate calculations.</p>

<p>Observe that the object returned is a degree <code class="keyw">n</code> truncation of the infinite-dimensional cohomology ring. A consequence of this is that multiplying two elements whose product has degree greater than <code class="keyw">n</code> results in zero.</p>

<p>Observe also that calling <code class="keyw">CohomologyRing</code> a second time with a bigger <code class="keyw">n</code> does <em>not</em> extend the previous ring, but rather, recalculates the entire ring from the beginning. Admittedly, this is rather inconvenient, and I promise to think about extending the previous ring the next time I find myself drinking a martini on the beach with my laptop.</p>

<p><a id="s4ss2" name="s4ss2"></a></p>

<h5>2.4-2 IsHomogeneous</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; IsHomogeneous</code>( <var>e</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p><b>Returns: </b><code class="keyw">true</code> or <code class="keyw">false</code>.</p>

<p>Given an element <code class="keyw">e</code> of some cohomology ring A, this operation determines whether or not <code class="keyw">e</code> is homogeneous, that is, whether or not <code class="keyw">e</code> is contained in some <code class="keyw">hom_component</code> of A.</p>

<p><a id="s4ss3" name="s4ss3"></a></p>

<h5>2.4-3 Degree</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; Degree</code>( <var>e</var> )</td><td class="tdright">( method )</td></tr></table></div>
<p><b>Returns: </b>the degree of <code class="keyw">e</code>.</p>

<p>This function is intended to return the degree of the possibly non-homogeneous element <code class="keyw">e</code> of some cohomology ring A, but in principle, works for any element of any graded <code class="keyw">SCAlgebra</code>. Specifically, if A = A_0 + A_1 + A_2 + ... with A_i the <code class="keyw">hom_components</code> of A, then this function returns the minimum n such that <code class="keyw">e</code> is in A_0 + A_1 + ... + A_n.</p>


<table class="example">
<tr><td><pre>

gap&gt; A:=CohomologyRing(DihedralGroup(8),10);
&lt;algebra of dimension 66 over GF(2)&gt;
gap&gt; b:=Basis(A);
CanonicalBasis( &lt;algebra of dimension 66 over GF(2)&gt; )
gap&gt; x:=b[2]+b[4];
v.2+v.4
gap&gt; IsHomogeneous(x);
false
gap&gt; Degree(x);
2 

</pre></td></tr></table>

<p><a id="s4ss4" name="s4ss4"></a></p>

<h5>2.4-4 LocateGeneratorsInCohomologyRing</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; LocateGeneratorsInCohomologyRing</code>( <var>C</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>a list containing the cohomology generators.</p>

<p>Having already called <code class="keyw">CohomologyRing</code> (see <a href="chap2.html#s4ss1"><b>2.4-1</b></a>), this function returns a list of elements of the cohomology ring which together with the identity element of the ring generate it as a ring.</p>

<p>This function is a wrapper for <code class="keyw">CohomologyGenerators</code> (see <a href="chap2.html#s3ss1"><b>2.3-1</b></a>), indicating which elements of the cohomology ring correspond with the generators found by <code class="keyw">CohomologyGenerators</code>.</p>


<table class="example">
<tr><td><pre>

gap&gt; C:=CohomologyObject(SmallGroup(8,4));
&lt;object&gt;
gap&gt; A:=CohomologyRing(C,10);
&lt;algebra of dimension 17 over GF(2)&gt;
gap&gt; L:=LocateGeneratorsInCohomologyRing(C);
[ v.2, v.3, v.7 ]
gap&gt; A=Subalgebra(A,Concatenation(L,[One(A)]));
true

</pre></td></tr></table>

<p><a id="s5ss0" name="s5ss0"></a></p>

<h4>2.5 Induced Maps</h4>

<p>Let f: G -&gt; H be a group homomorphism for p-groups G and H. Then f induces a homomorphism on cohomology H*(H,k) -&gt; H*(G,k) which is returned by the following function.</p>

<p><a id="s5ss1" name="s5ss1"></a></p>

<h5>2.5-1 InducedHomomorphismOnCohomology</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; InducedHomomorphismOnCohomology</code>( <var>C, D, f, n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>the induced homomorphism on cohomology rings.</p>

<p>This function returns the induced homomorphism on cohomology H*(H,k) -&gt; H*(G,k) where the groups G and H are the components of the cohomology objects <code class="keyw">C</code> and <code class="keyw">D</code> and f: G -&gt; H is a group homomorphism. If the cohomology rings have not yet been calculated, they will be computed to degree n, and in this case, they can then be accessed by calling <code class="keyw">CohomologyRing</code> (see <a href="chap2.html#s4ss1"><b>2.4-1</b></a>).</p>

<p>The following example calculates the homomorphism on cohomology induced by the inclusion of the cyclic group of size 4 into the dihedral group of size 8.</p>


<table class="example">
<tr><td><pre>


gap&gt; G:=CyclicGroup(4);H:=DihedralGroup(8);
&lt;pc group of size 4 with 2 generators&gt;
&lt;pc group of size 8 with 3 generators&gt;
gap&gt; C:=CohomologyObject(G);D:=CohomologyObject(H);
&lt;object&gt;
&lt;object&gt;
gap&gt; f:=GroupHomomorphismByImages(G,H,[G.1],[H.2]);
[ f1 ] -&gt; [ f2 ]
gap&gt; F:=InducedHomomorphismOnCohomology(C,D,f,10);
CanonicalBasis( &lt;algebra of dimension 66 over GF(2)&gt; ) -&gt;
[ v.1, 0*v.1, v.2, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1,
  0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1,
  0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1,
  0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1,
  0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1,
  0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1,
  0*v.1, 0*v.1, 0*v.1, 0*v.1, 0*v.1 ]
gap&gt; B:=CohomologyRing(D,10);
&lt;algebra of dimension 66 over GF(2)&gt;
gap&gt; B.1^F;B.2^F;
v.1
0*v.1

</pre></td></tr></table>

<p><a id="s6ss0" name="s6ss0"></a></p>

<h4>2.6 Massey Products</h4>

<p>See <a href="chapBib.html#biBkraines">[K66]</a> for the definitions and <a href="chapBib.html#biBborge">[B01]</a> for the details of the calculation using the Yoneda cocomplex. See also the file <code class="keyw">doc/explanation.tex</code> for an explanation of the implementation.</p>

<p><a id="s6ss1" name="s6ss1"></a></p>

<h5>2.6-1 MasseyProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&gt; MasseyProduct</code>( <var>x1, x2, ..., xn</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p><b>Returns: </b>the Massey product &lt; x1, x2, ... , xn&gt;.</p>

<p>Given elements x1, x2, ... , xn of a cohomology ring returned by <code class="keyw">CohomologyRing</code> (see <a href="chap2.html#s4ss0"><b>2.4</b></a>), this function computes the n-fold Massey product &lt; x1, x2, ... , xn &gt; provided that the lower-degree Massey products &lt; x_i ,x_{i+1}, ... , x_j &gt; vanish for all 1 &lt;= i &lt; j &lt;= n, and returns <code class="keyw">fail</code> otherwise.</p>

<p>As an example, recall that the cohomology rings of the cyclic groups C_3 and C_9 of size 3 and 9 over k=GF(3) are both given by k&lt; z,y &gt;/(z^2), that is, they are isomorphic as rings. However, the following example shows that &lt; z, z, z &gt; is non-zero in H*(C_3,k) but is zero in H*(C_9,k).</p>


<table class="example">
<tr><td><pre>


gap&gt; A:=CohomologyRing(CyclicGroup(3),10);
&lt;algebra of dimension 11 over GF(3)&gt;
gap&gt; z:=Basis(A)[2];
v.2
gap&gt; MasseyProduct(z,z);
0*v.1
gap&gt; MasseyProduct(z,z,z);
v.3
gap&gt; A:=CohomologyRing(CyclicGroup(9),10);
&lt;algebra of dimension 11 over GF(3)&gt;
gap&gt; z:=Basis(A)[2];
v.2
gap&gt; MasseyProduct(z,z);
0*v.1
gap&gt; MasseyProduct(z,z,z);
0*v.1
gap&gt; MasseyProduct(z,z,z,z,z,z,z,z,z);
v.3


</pre></td></tr></table>


<div class="pcenter">
<table class="chlink"><tr><td><a href="chap0.html">Top of Book</a></td><td><a href="chap1.html">Previous Chapter</a></td><td><a href="chap3.html">Next Chapter</a></td></tr></table>
<br />


<div class="pcenter"><table class="chlink"><tr><td class="chlink1">Goto Chapter: </td><td><a href="chap0.html">Top</a></td><td><a href="chap1.html">1</a></td><td><a href="chap2.html">2</a></td><td><a href="chap3.html">3</a></td><td><a href="chapBib.html">Bib</a></td><td><a href="chapInd.html">Ind</a></td></tr></table><br /></div>

</div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
